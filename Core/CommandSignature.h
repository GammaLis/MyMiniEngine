#pragma once
#include "pch.h"

namespace MyDirectX
{
	class RootSignature;

	class IndirectParameter
	{
		friend class CommandSignature;

	public:
		IndirectParameter()
		{
			m_IndirectParam.Type = (D3D12_INDIRECT_ARGUMENT_TYPE)0xFFFFFFFF;
		}

		void Draw() { m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW; }
		void DrawIndexed() { m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED; }
		void Dispatch() { m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH; }
		
		void VertexBufferView(UINT slot)
		{
			m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW;
			m_IndirectParam.VertexBuffer.Slot = slot;
		}

		void IndexBufferView()
		{
			m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW;
		}

		void Constant(UINT rootParameterIndex, UINT destOffsetIn32BitValues, UINT num32BitValuesToSet)
		{
			m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT;
			m_IndirectParam.Constant.RootParameterIndex = rootParameterIndex;
			m_IndirectParam.Constant.DestOffsetIn32BitValues = destOffsetIn32BitValues;
			m_IndirectParam.Constant.Num32BitValuesToSet = num32BitValuesToSet;
		}

		void ConstantBufferView(UINT rootParameterIndex)
		{
			m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW;
			m_IndirectParam.ConstantBufferView.RootParameterIndex = rootParameterIndex;
		}

		void ShaderResourceView(UINT rootParameterIndex)
		{
			m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW;
			m_IndirectParam.ShaderResourceView.RootParameterIndex = rootParameterIndex;
		}

		void UnorderedAccessView(UINT rootParameterIndex)
		{
			m_IndirectParam.Type = D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW;
			m_IndirectParam.UnorderedAccessView.RootParameterIndex = rootParameterIndex;
		}

		const D3D12_INDIRECT_ARGUMENT_DESC& GetDesc() const { return m_IndirectParam; }

	protected:
		D3D12_INDIRECT_ARGUMENT_DESC m_IndirectParam;

	};

	class CommandSignature
	{
	public:
		CommandSignature(UINT numParams = 0) : m_Finalized(FALSE), m_NumParameters(numParams)
		{
			Reset(numParams);
		}

		void Destroy()
		{
			m_Signature = nullptr;
			m_ParamArray = nullptr;
		}

		void Reset(UINT numParams)
		{
			if (numParams > 0)
				m_ParamArray.reset(new IndirectParameter[numParams]);
			else
				m_ParamArray = nullptr;
			m_NumParameters = numParams;
		}

		IndirectParameter& operator[](size_t entryIndex)
		{
			ASSERT(entryIndex < m_NumParameters);
			return m_ParamArray[entryIndex];	// m_ParamArray.get()[entryIndex]
		}

		const IndirectParameter& operator[](size_t entryIndex) const
		{
			ASSERT(entryIndex < m_NumParameters);
			return m_ParamArray[entryIndex];
		}

		void Finalize(ID3D12Device *pDevice, const RootSignature* rootSignature = nullptr);

		ID3D12CommandSignature* GetSignature() const { return m_Signature.Get(); }

	private:
		BOOL m_Finalized;
		UINT m_NumParameters;
		std::unique_ptr<IndirectParameter[]> m_ParamArray;
		Microsoft::WRL::ComPtr<ID3D12CommandSignature> m_Signature;
	};

}

/**
* >> Indirect Drawing
* https://learn.microsoft.com/en-us/windows/win32/direct3d12/indirect-drawing
*	Indirect drawing enables some scene-traversal and culling to be moved from the CPU to the GPU,
* which can improve performance. The command buffer can be generated by the CPU or GPU.
*
* >> CommandSignature
* The command signature object ('ID3DCommandSignature') enables apps to specify indirect drawing, in particular
* setting the following:
* * the indirect argument buffer format
* * the command type that will be used ('DrawInstance', 'DrawIndexedInstanced', 'Dispatch', ...)
* * the set of resource bindings which will change per-command call versus the set which be inherited
*	At startup, an app creates a small set of 'command signatures'. At runtime, the application fills a buffer
* with commands. The commands optionally containing state to set for vertex buffer views, index buffer views,
* root constants and root descriptors (raw or structured SRV/UAV/CBVs). These argument layouts are not hardware
* specific so apps can generate the buffers directly.
*	The the app calls 'ExecuteIndirect' to instruct the GPU to interpret the contents of the indirect argument
* buffer according to the format defined by a particular command signature.
*
*	No command signature state leaks back to the command list after the execution is complete. But, after 'ExecuteIndirect'
* all bindings are reset to known values. In particular
* * if the command signature binds a vertex buffer to a particular slot, then after 'ExecuteIndirect' is called,
* a NULL vertex buffer is bound to that slot.
* * if the command signature binds an index buffer, then after 'ExecuteIndirect', a NULL index buffer is bound
* * if the command signature sets a root constant, then after 'ExecuteIndirect' is called, the root constant value
* is set to 0.
* * if the command signature sets a root view (CBV/SRV/UAV), then after 'ExecuteIndirect' is called, the root view
* is set to a NULL view.
*
* >> Example
*	Suppose an app developer wants a unique root constant to be specified per-draw call in the indirect argument
* buffer. The app would create a command signature that enables the indirect argument buffer to specify the following
* parameters per draw call:
* * the value of the root constant
* * the draw arguments (vertex count, instance cout, etc)
*	The indirect argument buffer generated by the app would contain an array of fixed-size records. Each structure
* corresponds to one draw call. Each structure contains the drawing arguments, and the value of the root constant.
*/
