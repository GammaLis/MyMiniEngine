#ifndef RANDOM_INCLUDED
#define RANDOM_INCLUDED

#ifndef USE_PCG
#define USE_PCG 1
#endif

/// RNG
#if USE_PCG
	#define RngStateType uint4
#else
	#define RngStateType uint
#endif

// PCG random number generator
// Ref: "Hash Functions for GPU Rendering" by Jarzynski & Olano
// (pixel's screen coordinates, frame number, current sample index)
uint4 Pcg4D(uint4 v)
{
	v = v * 1664525u + 1013904223u;

	v.x += v.y * v.w; 
	v.y += v.z * v.x; 
	v.z += v.x * v.y; 
	v.w += v.y * v.z;

	v = v ^ (v >> 16u);

	v.x += v.y * v.w; 
	v.y += v.z * v.x; 
	v.z += v.x * v.y; 
	v.w += v.y * v.z;

	return v;
}
/**
 * The 4 inputs PCG4D requires are readily available in the ray generation shader; however, they must
 * be passed into other shader stages (e.g. closest and any-hit). For best performance, the payload
 * that passes data between ray tracing shader stages should be kept as small as possible, so we hash 
 * the 4 inputs to a more compact seed value before passing it into the other shader stage.
 */

// 32-bit Xorshift random number generator
uint Xorshift(inout uint rngState)
{
	rngState ^= rngState << 13;
	rngState ^= rngState >> 17;
	rngState ^= rngState << 5;
	return rngState;
}

// Jenkin's "one at a time" hash function
uint JenkinsHash(uint x)
{
	x += x << 10;
	x ^= x >> 6;
	x += x << 3;
	x ^= x >> 11;
	x += x << 15;
	return x;
}

// Converts unsigned integer into float int range <0; 1) by using 23 most significant bits for mantissa
// of the floating-point number representation and setting the sign bits and exponent to 0.
float UintToFloat(uint x) {
	return asfloat(0x3f800000 | (x >> 9)) - 1.0f;
}

#if USE_PCG

// Initialize RNG for given pixel, and frame number (PCG version)
RngStateType InitRNG(uint2 pixelCoord, uint2 resolution, uint frameNumber)
{
	//< Seed for PCG uses a sequential sample number in 4th channel, which increments on every RNG call and
	// starts from 0
	return RngStateType(pixelCoord.xy, frameNumber, 0);
}

// Return random float in [0, 1) range (PCG version)
float Rand(inout RngStateType rngState)
{
	rngState.w++; //< Increment sample index
	return UintToFloat(Pcg4D(rngState).x);
}

#else // USE_PCG

// Initialize RNG for given pixel, and frame number (Xorshift-based version)
RngStateType InitRNG(uint2 pixelCoord, uint2 resolution, uint frameNumber) 
{
	RngStateType seed = dot(pixelCoord, uint2(1, resolution.x)) ^ JenkinsHash(frameNumber);
	return JenkinsHash(seed);
}

// Return random float in <0; 1) range (Xorshift-based version)
float Rand(inout RngStateType rngState) 
{
	return UintToFloat(Xorshift(rngState));
}

#endif // USE_PCG

// Maps integers to colors using the hash function (generates pseudo-random colors)
float3 HashAndColor(int i)
{
	uint hash = JenkinsHash(i);
	float r = ((hash >>  0) & 0xFF) / 255.0f;
	float g = ((hash >>  8) & 0xFF) / 255.0f;
	float b = ((hash >> 16) & 0xFF) / 255.0f;
	return float3(r, g, b);
}

#endif // RANDOM_INCLUDED

/**
 * >> Random number generator
 *  At the core of every path tracer, there is a random number generator (RNG). Random numbers are 
 * necessary to drive the sampling of materials, lights, procedurally generated textures, and must more 
 * as the path tracer simulates light transport.
 * 	A fast and popular shader-based method is an xorshift function or linear congruential generator (LCG)
 * seeded with a hash function. First the random seed for the RNG is established by hashing the current
 * pixel's screen coordinates and the frame number. This hashing ensures a good distribution of random numbers
 * spatially across neighboring pixels and temporally across subsequent frames.
 * 	Next, each new random number is generated by converting the seed into a floating-point number and 
 * hashing it again. Notice how the `rand` function modifies the RNG's state. Since the generated number is
 * a sequence of random bits forming an unsigned integer, we need to convert this to a floating-point number
 * in the range [0,1).
 */
